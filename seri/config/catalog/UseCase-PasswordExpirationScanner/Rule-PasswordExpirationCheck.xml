<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="Rule - Password Expiration Check">
  <Signature>
    <Inputs>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be use to access
          the database
        </Description>
      </Argument>
    </Inputs>

  </Signature>
  <Source><![CDATA[

import sailpoint.object.Identity;
import sailpoint.object.Capability;
import sailpoint.object.Application;
import sailpoint.api.SailPointContext;
import sailpoint.object.AuditEvent;
import sailpoint.object.EmailTemplate;
import sailpoint.object.EmailOptions;
import sailpoint.object.QueryOptions;
import sailpoint.object.Filter;
import java.util.List;
import java.text.SimpleDateFormat;
import java.util.TimeZone;
import java.util.Calendar;
import sailpoint.connector.LDAPConnector;
//import sailpoint.tools.xml.*;

import javax.naming.Context;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import javax.naming.ldap.InitialLdapContext;
import javax.naming.ldap.LdapContext;
import javax.naming.NamingEnumeration;
import sailpoint.tools.GeneralException;


// Not used in the task.  This was used as a first pass.
// Leaving it in SERI in case someone needs to use a rule rather than the TaskDefinition.


public void sendEmailExpiration(Identity identity, String type) {

	serilog.trace("sendEmailExpiration :: Enter");
	String toAddress = identity.getEmail();
	if (null == toAddress) {
	  toAddress = "noemail@sailpointdemo.com";
	}
	
	Map mailArgs = new HashMap();
	mailArgs.put("identityName",identity.getName());
	mailArgs.put("displayName",identity.getDisplayName());
	mailArgs.put("type", type);
	
	serilog.debug("\nsendEmailExpiration for " + identity.getName() + "of type " + type);
	String emailTemplateName = "Password Notification-HTML";
	EmailTemplate template = context.getObjectByName(EmailTemplate.class, emailTemplateName);
	if (template == null) {
	  serilog.error("sendEmailExpiration :: Template not found: " + emailTemplateName);
	  return;
	}
	
	EmailOptions mailopts = new EmailOptions(toAddress, mailArgs);
	
	context.sendEmailNotification(template, mailopts);
	serilog.trace("sendEmailExpiration :: Email Sent");

}


// Start off execution here, after the above functions have been declared.
// Passwords are good for 80 days.
serilog = org.apache.commons.logging.LogFactory.getLog("SERI.Rule.PasswordExpirationCheck");

// Allow the script to be run in "testMode". In "testMode" we only output the
// details for who has invalid passwords and do not send out email notifications.
// When testMode is false we send out email notifications to the users.
boolean testMode = true;


// CHANGE TEHSE VALUES!!
// TODO: Pull these details from the "Enterprise LDAP" or "Enterprise Directory"
// application obect and don't hard-code them here.
String searchBase = "ou=Demo,dc=seri,dc=sailpointdemo,dc=com";
String host = "seri.sailpointdemo.com";
String port = "389";
String securityPrincipal = "SERI\\Administrator";
String securityCredentials = "sailpoint";
String authenticationMode = "simple";

// LDAP search controls
SearchControls searchCtls = new SearchControls();
searchCtls.setSearchScope(SearchControls.SUBTREE_SCOPE);

SearchControls searchCtlsAD = new SearchControls();
searchCtlsAD.setSearchScope(SearchControls.ONELEVEL_SCOPE);



// Using standard Port, check your installation
Hashtable environment = new Hashtable();
environment.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
environment.put(Context.PROVIDER_URL, "ldap://" + host + ":" + port);
environment.put(Context.SECURITY_PRINCIPAL, securityPrincipal);
environment.put(Context.SECURITY_CREDENTIALS, securityCredentials);
environment.put(Context.SECURITY_AUTHENTICATION, authenticationMode);
environment.put(Context.REFERRAL,"follow");

NamingEnumeration results = null;
long mpaLong;
long EPOCHOFFSET = 11644473600000L;
long ONE_HUNDRED_NANO = 10000L;
long ONE_DAY_NANO = -864000000000L;
long DAY_RANGE = 42L;  //Set this to some value less than maxpwd age.   We will use MaxPwdAge and this day value to create a range of users to notify


try {

  // Connect to the LDAP Environment
  LdapContext ctxGC = new InitialLdapContext(environment, null);


  /********************************************************/
  /*        maxPwdAge Day Check							*/
  /********************************************************/
  //MaxPwdAge is stored on root dn.
	serilog.debug("\n\n\n");
	String maxpwdageFilter = "(objectclass=domain)";
	String maxpwdageSearchBase = "dc=seri,dc=sailpointdemo,dc=com";
	NamingEnumeration mpaResults = ctxGC.search(maxpwdageSearchBase, maxpwdageFilter, searchCtls);
	String maxPwdAge = null;
	while (mpaResults.hasMore()) {

    SearchResult mpaResult = (SearchResult) mpaResults.next();

    Attributes attributes = mpaResult.getAttributes();
    maxPwdAge = attributes.get("maxPwdAge").get();

	  //maxPawdAge is a negative value.   If not found, just exit.
	  if (maxPwdAge != null) {
      mpaLong = Long.parseLong(maxPwdAge);
      serilog.debug("MaxPasswordAge = " + mpaLong);
	  } else {
	     GeneralException ge = new GeneralException("No MaxPasswordAge");
		 throw ge;
	     return "No PasswordAge";
	  }

  }

	/********************************************/
  /*        User pwdLastSet Check							*/
  /********************************************/

	//Get the current time in Millis
	Calendar nowCalendar = Calendar.getInstance();
	long nowUnixEpoch = nowCalendar.getTimeInMillis();
	serilog.debug("Current Time in Millis = " + nowUnixEpoch);

  //Unix Epoch is number of milliseconds since Jan 1, 1970
	//Windows Epoch is number of 100 nano seconds since Jan 1, 1601
	//Add the number of Milliseconds between Jan 1, 1601 and Jan 1, 1970
	long nowWindowsOffset = (nowUnixEpoch + EPOCHOFFSET);

	//Now multiply to get 100 nanoseconds
	long nowWindowslong = (nowWindowsOffset * ONE_HUNDRED_NANO);
	serilog.debug("Current Windows Time = " + nowWindowslong);


	//Add Current time to MaxPwdAge.   MaxPwdAge is negative value.
	//This gives us a value used to query passwords that will expire soon.
	long pwdWillExpire = nowWindowslong + mpaLong;
	serilog.debug("pwdWillExpire = " + pwdWillExpire);


	//SET THIS VALUE!
	//This will set the lower range of pwdLastSet.   This value should be greater than pwdWillExpire!
	long pwdUpperRange = nowWindowslong - (ONE_DAY_NANO * DAY_RANGE);

	//Only get users who have pwdLastSet set and within a certain range.   Also, ignore users who's passwords don't expire
  String pwdLastSetFilter = "(&(objectClass=person)(pwdLastSet=*)(pwdLastSet>=" + pwdWillExpire + ")(pwdLastSet<=" + pwdUpperRange + ")(!(userAccountControl=65536)))";
  //(!userAccountControl=65536)
	serilog.debug("pwdLastSetFilter = " + pwdLastSetFilter);

	//Used to find out how many users are affected.
  int pwdcount = 0;

  // Execute an LDAP search and Loop through the results
  results = ctxGC.search(searchBase, pwdLastSetFilter, searchCtls);


  while (results.hasMore()) {
	  serilog.debug("Executed Search");
    pwdcount++;

    SearchResult result = (SearchResult) results.next();

    Attributes attributes = result.getAttributes();
    String dn = attributes.get("distinguishedName").get();
		String pwdLastSet = attributes.get("pwdLastSet").get();

		serilog.debug("\n\ndn: " +dn);
		serilog.debug("pwdLastSet: " + pwdLastSet);


		//Now lets do some math to figure out how many days till the pwd expires.
		Long pwdLastSetLong = new Long(pwdLastSet);
		long daysToExpire = pwdLastSetLong.longValue() - pwdWillExpire;
		//serilog.debug("daysToExpire = " + daysToExpire);

		long days = (daysToExpire / (10000000L * 24L * 60L * 60L));
		serilog.debug("days = " + days);

		//Try to find a corresponding Identity to send an email to.
		//May have to do a Filter


		QueryOptions qo = new QueryOptions();
		qo.addFilter(Filter.and(Filter.eq("links.application.name","Active Directory"), Filter.eq("links.nativeIdentity",dn)));

        Iterator idResult = context.search(Identity.class,qo);

		//Assuming we only get one result back!
    if (idResult.hasNext()) {
      Identity identity = idResult.next();
      if ( !testMode ) {
        sendEmailExpiration(identity, ""+days);
      } else {
        serilog.debug("testMode: Skipping email for " + identity.getName());
      }
    } else {
      serilog.debug("Found Password Expiration but no corresponding user");
    }
  }


  serilog.debug("Users to Notify of Password Expiration: " + pwdcount);

} catch (Exception e) {
    serilog.debug("General Exception: " + e.getMessage());
}

return "Success";
]]>
  </Source>
</Rule>